# Проект: Покупка авиабилета — Микросервисная архитектура

## Предметная область

Данный проект моделирует процесс покупки авиабилета. Пользователь выбирает рейс, бронирует место, оплачивает билет и получает подтверждение. В случае ошибки (например, если платеж не прошел или мест не осталось), система должна корректно обработать сбой и отменить бронь. Это пример распределенной системы, где требуется надежная и согласованная обработка бизнес-событий.

---

## 1. Сервисная архитектура

В проекте реализована микросервисная архитектура. Каждый сервис отвечает за строго определённую бизнес-функцию и работает независимо:

- **Booking Service** — отвечает за создание бронирований и их подтверждение.
- **Flight Service** — управляет данными о рейсах и доступности мест.
- **Payment Service** — обрабатывает оплату брони.

Каждый из этих сервисов запускается как отдельный контейнер (см. `docker-compose.yml`) и взаимодействует с остальными сервисами через сообщения, а не напрямую. Это снижает связанность между компонентами системы и повышает отказоустойчивость.

---

## 2. Redis и его использование

Для асинхронного взаимодействия между сервисами используется **Redis** — высокопроизводительная структура данных, предназначенная для очередей сообщений.

С помощью Redis реализован обмен событиями между сервисами: каждый сервис публикует события в поток, а другие подписаны на соответствующие группы сообщений. Это обеспечивает:

- Асинхронность и отказоустойчивость.
- Возможность масштабирования (группы потребителей).
- Возможность повторной доставки сообщений при сбоях.

Примеры событий:
- `booking_requested`
- `seat_reserved`
- `payment_processed`
- `booking_confirmed`
- `booking_failed`

---

## 3. Inbox / Outbox

Эти паттерны помогают безопасно передавать события между сервисами.

### Inbox

- Когда сервис получает событие, он сохраняет его в отдельной таблице.
- Проверяет, не обрабатывал ли он его раньше.
- Это защищает от повторной обработки одного и того же события.

### Outbox

- Событие сначала сохраняется в базу данных в специальной таблице.
- Потом оно отправляется в очередь сообщений.
- Это защищает от потери события при сбоях.

---

## 4. Паттерн Оркестрация

Оркестрация — это архитектурный паттерн взаимодействия микросервисов, при котором один из компонентов системы (называемый оркестратором) централизованно управляет выполнением бизнес-процесса. Он знает все этапы взаимодействия между сервисами и инициирует вызовы или события в нужной последовательности.

Оркестратор принимает решения, отслеживает состояние всего процесса и направляет поток управления, обеспечивая явную координацию всех шагов.

В данном проекте паттерн оркестрации реализован с использованием микросервиса `svc_booking`, который выступает в роли **центрального оркестратора бизнес-процесса** бронирования. Он отвечает за координацию всех остальных сервисов:

1. Получает запрос от пользователя на создание брони (например, через API).
2. Сохраняет информацию о бронировании в БД.
3. Генерирует и публикует событие `booking_requested` в очередь (Redis Stream).
4. Получает от других сервисов события `seat_reserved`, `seat_unavailable`, `payment_success`, `payment_failed` и в зависимости от этого:
   - подтверждает или отклоняет бронь;
   - отправляет уведомление пользователю;
   - сохраняет финальный статус в БД.

Таким образом, `svc_booking` координирует цепочку событий между:
- `svc_flight` — проверка и резервирование места;
- `svc_payment` — симуляция оплаты;
- и сам собой — для обновления состояния брони в зависимости от результата каждого этапа.

Сами сервисы `svc_flight` и `svc_payment` **не знают друг о друге** и не координируют процесс напрямую. Все управление идёт через `svc_booking`, что и делает его **центральной точкой оркестрации**.